import SimpleOpenNI.*;
import processing.serial.*;
import processing.net.*;
import java.awt.*;
SimpleOpenNI kinect;
KinectTracker kt;

int lowX;
int lowY;
boolean hit = false;
boolean hit2 = false;
int x2 = 50;
int y2 = 300;
int r_highX;
int r_highY;
int r_lowX;
int r_lowY;

int lowX2;
int lowY2;

int r_highX2;
int r_highY2;
int r_lowX2;
int r_lowY2;
int theta2 = 0;
int toggle = -1;


import ddf.minim.analysis.*;
import ddf.minim.*;

Minim       minim;
AudioInput  accessMic;
FFT         fft;
int sampleRate= 44100;//sapleRate of 44100
float [] max= new float [sampleRate/2];//array that contains the half of the sampleRate size, because FFT only reads the half of the sampleRate frequency. This array will be filled with amplitude values.
float maximum;//the maximum amplitude of the max array
float frequency;//the frequency in hertz

float[] angles = new float[9];
int skeletonid = 1;

float alpha = 0.5;
float l_yvel = 0;
float gravity = 9.8; //how fast the paddle falls
float exceed_gravity = 9.8; //volume must exceed this to fall
final float SCALER = -1000; //change how much an affect loudness has
boolean handTrackFlag = false;


int rightPadY=0;
int rightPadX=0;//changed in setup
int leftPadY=0;
int leftPadX=0;
int paddleH=100;
int paddleW=33;
int ballS=50; //ball size
int ballXSpeed=5;
int ballYSpeed=5;
int ballX=500;
int ballY=500;
int leftScore=0;
int rightScore=0;

//networking
Server myServer;
Client myClient;
String input;
int[] otherCords={0,0,0,0,0,0,0,0}; 
int[] copy_cords={0,0,0,0,0,0,0};
int prevLeft = 0;
int prevMapX = 0;
float scaledX;
float scaledY;
int diffX = 0;


boolean checkIntersection(float x1, float y1, float x2, float y2, 
float cx, float cy, float cr ) {
  float dx = x2 - x1;
  float dy = y2 - y1;
 
  float a = dx*dx + dy*dy;
  float b = (dx*(x1 - cx) + (y1 - cy)*dy) * 2;
  float c = cx*cx + cy*cy;
 
  c += x1*x1 + y1*y1;
  c -= (cx*x1 + cy*y1) * 2;
  c -= cr*cr;
 
  float delta = b*b - 4*a*c;
 
  if (delta < 0)   return false; // Not intersecting
 
  delta = sqrt(delta);
 
  float mu = (-b + delta) / (2*a);
  float ix1 = x1 + mu*dx;
  float iy1 = y1 + mu*dy;
 
  mu = (b + delta) / (-2*a);
  float ix2 = x1 + mu*dx;
  float iy2 = y1 + mu*dy;
 
  // Intersection points
  fill(#FF0000);
  ellipse(ix1, iy1, 5, 5);
  ellipse(ix2, iy2, 5, 5);
 
  // Figure out which point is closer to the circle
  boolean test = dist(x1, y1, cx, cy) < dist(x2, y2, cx, cy);
 
  float closerX = test? x2:x1;
  float closerY = test? y2:y1;
 
  return dist(closerX, closerY, ix1, iy1) < dist(x1, y1, x2, y2) || 
    dist(closerX, closerY, ix2, iy2) < dist(x1, y1, x2, y2);
}

//
//PFont font;
PVector handVec = new PVector();
PVector mapHandVec = new PVector();
color handPointCol = color(255,0,0);

void setup() {
  size(1200, 650);
 kinect = new SimpleOpenNI(this);
 kt = new KinectTracker();
 frameRate(60);
 rightPadX=(width)-paddleW;
 minim = new Minim(this);
  accessMic = minim.getLineIn(Minim.MONO, 4096, sampleRate);
  fft = new FFT(accessMic.left.size(), sampleRate);
  myClient = new Client(this, "127.0.0.1", 12366); // Replace with your serverâ€™s IP and port


 
} 

void onRecognizeGesture(String strGesture, PVector idPosition, PVector endPosition)
{
  String prevGest = strGesture;
} 

void onCreateHands(int handId, PVector pos, float time)
{
 handVec = pos;
 handPointCol = color(0, 255, 0);
} 

void onDestroyHands( int handId, float time ) {
  handTrackFlag=false;
}

void onUpdateHands(int handId, PVector pos, float time)
{
 handVec = pos;
} 


void onProgressGesture(String strGesture, PVector position,float progress){
  println("onProgressGesture - strGesture: " + strGesture + ", position: " + position + ", progress:" + progress);
  kinect.startTrackingHands(position);
  if(!kinect.isTrackingSkeleton(skeletonid)){
   kinect.requestCalibrationSkeleton(skeletonid, true);
  }
 
 handTrackFlag=true;
}

void draw() {
  if(toggle > 0) 
    game();
   else
     text("Press enter to start",width/4, height/4, width/2, height/2);
}
 void game(){ 
  input=null;
 background(255,0,0);
 kt.display();

 textSize(50);
 fill(0, 102, 153);
 text(leftScore, 50, 60);
  fill(0, 102, 153);
  text(rightScore, width-paddleH, 60);
  ellipseMode(CENTER);
  
  // Start freq
  fft.forward(accessMic.left);
  for (int f=0;f<sampleRate/2;f++) { //analyses the amplitude of each frequency analysed, between 0 and 22050 hertz
    max[f]=fft.getFreq(float(f)); //each index is correspondent to a frequency and contains the amplitude value 
  }
  maximum=max(max);//get the maximum value of the max array in order to find the peak of volume
 
  for (int i=0; i<max.length; i++) {// read each frequency in order to compare with the peak of volume
    if (max[i] == maximum) {//if the value is equal to the amplitude of the peak, get the index of the array, which corresponds to the frequency
      frequency= i;
    }
  }
  float avg = (accessMic.left.level()+accessMic.right.level())/2;
  //Left Pad
  
  l_yvel = (alpha * ((avg * SCALER) - leftPadY))+((1-alpha) * leftPadY);
  //println(r_yvel);
  if(abs(l_yvel) < exceed_gravity){
    l_yvel = gravity;
  }
  leftPadY += l_yvel;
  if (leftPadY <= 0){
    leftPadY = 0;
  }
  else if(leftPadY >= height - 100){
    leftPadY = height - 100;
  }
  
  if(handTrackFlag == true){

   prevMapX = leftPadX;
   leftPadX = (int)(mapHandVec.x * scaledX);
   diffX = leftPadX - prevMapX;
  }
  else
    diffX = 0;

  
  if(leftPadX < 0)
    leftPadX = 0;
  else if(leftPadX > (width*1/3) - paddleW)
    leftPadX = (width*1/3) - paddleW;
  
  
  myClient.write(leftPadX+" "+leftPadY+" "+angles[6]+" "+ballXSpeed"\n");
  rect(leftPadX,leftPadY,paddleW,paddleH);
   if(myClient.available()> 0) //available() returns number of bytes available so if it's >0 there is a message
  {
      input=myClient.readString();
      if(input.indexOf("\n") != -1)
      {
        input = input.substring(0, input.indexOf("\n"));  // Only up to the newline
        if(input.length() < 7)
          println(input.length());
        otherCords = int(split(input, ' '));  // Split values into an array
        if(otherCords.length < 7)
          println(otherCords.length);
    }
  }
  try{
  rightPadX=otherCords[0];
  rightPadY=otherCords[1];
  ballX=otherCords[2];
  ballY=otherCords[3];
  leftScore=otherCords[4];
  rightScore=otherCords[5];
  theta2 = otherCords[6];
  ballXSpeed = otherCords[7];
  for(int i =0; i < otherCords.length;i++){
    copy_cords[i] = otherCords[i];
  }
  }
  catch(ArrayIndexOutOfBoundsException e){
  rightPadX = copy_cords[0];
  rightPadY= copy_cords[1];
  ballX= copy_cords[2];
  ballY= copy_cords[3];
  leftScore = copy_cords[4];
  rightScore= copy_cords[5];
  theta2 = copy_cords[6];
  ballXSpeed = copy_cords[7];
  println("Size: " + otherCords.length + "\n" + e.toString());
}


pushMatrix();
  // move the origin to the pivot point
  translate(leftPadX, leftPadY); 
  
  // then pivot the grid
  rotate(radians(angles[6]));
  
  // and draw the square at the origin
  //fill(0);
   fill(#0000FF);
  rect(0, 0, paddleW, paddleH);
  popMatrix();

  lowX2 = (int)((leftPadX) + (paddleH * -cos(radians(90-angles[6]))));
  lowY2= (int)((leftPadY) + (paddleH * sin(radians(90-angles[6]))));

  r_highX2 = (int)((leftPadX) + (paddleW * cos(radians(angles[6]))));
  r_highY2= (int)((leftPadY) + (paddleW * sin(radians(angles[6]))));
  //top line
 // line(r_highX,r_highY, x,y);
  r_lowX2 = (int)(sin(radians(angles[6])) * (paddleH*sin(radians(90))));
  r_lowY2= (int)(-cos(radians(angles[6])) * (paddleH*sin(radians(90))));

  fill(0,255,0);
  //top left
  ellipse(leftPadX,leftPadY,5,5);
  //bottom left
  ellipse(lowX2,lowY2,5,5);
  //top right
  ellipse(r_highX2,r_highY2,5,5);
  //bottom right
  ellipse(r_highX2 - r_lowX2,-r_lowY2 + r_highY2,5,5);
  

 //Right pad
  pushMatrix();
  // move the origin to the pivot point
//  translate(rightPadX + (paddleW/2), rightPadY + (paddleH/2)); 
  translate(rightPadX,rightPadY);   

  // then pivot the grid
  rotate(radians(theta2));
  
  // and draw the square at the origin
  //fill(0);
   fill(0,0,255);
  
//  rect(-paddleW/2, -paddleH/2, paddleW, paddleH);
 rect(0, 0, paddleW, paddleH);
 
  popMatrix();

  lowX = (int)((rightPadX ) + (paddleH * -cos(radians(90-theta2))));
  lowY= (int)((rightPadY ) + (paddleH * sin(radians(90-theta2))));

  r_highX = (int)((rightPadX) + (paddleW * cos(radians(theta2))));
  r_highY= (int)((rightPadY) + (paddleW * sin(radians(theta2))));

  r_lowX = (int)(sin(radians(theta2)) * (paddleH*sin(radians(90))));
  r_lowY= (int)(-cos(radians(theta2)) * (paddleH*sin(radians(90))));

  
    fill(0,255,0);
  ////top left
  ellipse(rightPadX ,rightPadY,5,5);
  ////bottom left
  ellipse(lowX,lowY,5,5);
  ////top right
  ellipse(r_highX,r_highY,5,5);
  ////bottom right
  ellipse(r_highX - r_lowX,-r_lowY + r_highY,5,5);
  
  ellipse(ballX,ballY,ballS,ballS);
  ballX+=ballXSpeed;
  ballY+=ballYSpeed;  
  //scoring
  if(ballX<=ballS/2)
  {
    ballXSpeed=-5;
    rightScore++;
    hit = false;
    hit2 = false;
    ballX=width/2; //reset ball
    ballS=50;
    ballXSpeed=-ballXSpeed; 
  }
  else if(ballX>=width-ballS/2)
  {
   ballXSpeed=5; 
   leftScore++;
  hit = false; 
  hit2 = false;
   ballX=width/2;
   ballS=50;
   ballXSpeed=-ballXSpeed; 
  }
  if(ballY>height-ballS/2) //stay in bounds in Y
  {
     ballYSpeed=-ballYSpeed; 
  }
  else if(ballY<ballS/2)
  {
     ballYSpeed=-ballYSpeed;
  }
  
  //checks bounds
  if(ballX>width-ballS/2) //stay in bounds in X
  {
     ballXSpeed=-ballXSpeed; 
  }
  else if(ballX<ballS/2)
  {
     ballXSpeed=-ballXSpeed; 
  }
  
  // check if ball has hit any side of the right paddle 
 if((checkIntersection(rightPadX,rightPadY, lowX, lowY, ballX,ballY, ballS/2) || (checkIntersection(rightPadX,rightPadY, r_highX, r_highY, ballX,ballY, ballS/2))
|| (checkIntersection(lowX,lowY, r_highX - r_lowX, r_highY - r_lowY, ballX,ballY, ballS/2)) || 
(checkIntersection(r_highX - r_lowX, r_highY - r_lowY , r_highX, r_highY, ballX,ballY, ballS/2)))
&& !hit){ // left side
 
    ballXSpeed *=-1;
    hit = true;
    hit2=false;
  }
   
  
  // left paddle
  if((checkIntersection(leftPadX,leftPadY, lowX2, lowY2, ballX,ballY, ballS/2) || checkIntersection(leftPadX,leftPadY, r_highX2, r_highY2, ballX,ballY, ballS/2)
  || checkIntersection(lowX2,lowY2, r_highX2 - r_lowX2, r_highY2 - r_lowY2, ballX,ballY, ballS/2) ||
  checkIntersection(r_highX2 - r_lowX2, r_highY2 - r_lowY2 , r_highX2, r_highY2, ballX,ballY, ballS/2)) && !hit2){ // left side
  if(ballXSpeed < 0)
      ballXSpeed-=abs(diffX/10);
    else
      ballXSpeed+=abs(diffX/10);
    ballXSpeed *=-1;
    hit2 = true;
    hit = false;
  }

  
  
  

  if ((keyPressed == true) && (key == 'o')) //closes the game
  {
    myClient.stop();
    exit();
  }
  else if ((keyPressed == true) && (key == ENTER)) //sets the toggle
  {  
    toggle *= -1;
  }
  
}



// -----------------------------------------------------------------
// SimpleOpenNI events

void onNewUser(int userId)
{
  println("onNewUser - userId: " + userId);
  println("  start pose detection");
  skeletonid = userId;  
}

void onLostUser(int userId)
{
  println("onLostUser - userId: " + userId);
}

void onExitUser(int userId)
{
  println("onExitUser - userId: " + userId);
}

void onReEnterUser(int userId)
{
  println("onReEnterUser - userId: " + userId);
}

void onStartCalibration(int userId)
{
  println("onStartCalibration - userId: " + userId);
}

void onEndCalibration(int userId, boolean successfull)
{
  println("onEndCalibration - userId: " + userId + ", successfull: " + successfull);
  
  if (successfull) 
  { 
    println("  User calibrated !!!");
    kinect.startTrackingSkeleton(userId); 

  } 
  else 
  { 
    println("  Failed to calibrate user !!!");
    println("  Start pose detection");
    kinect.startPoseDetection("Psi",userId);
  }
}
